/*
 * Copyright (C) 2004-2007 Duke University. This software is distributed under
 * the terms of the Eclipse Public License Version 1.0 found in
 * the file named LICENSE.Eclipse, which was shipped with this distribution.
 * Any use, reproduction or distribution of this software constitutes
 * the recipient's acceptance of the Eclipse license terms.
 * This notice and the full text of the license must be included with any
 * distribution of this software.
 */

package orca.shirako.kernel.interfaces;

import orca.shirako.api.ITick;
import orca.shirako.time.ActorClock;
import orca.util.Initializable;


/**
 * <code>ITicker</code> defines the interface for the internal clock of a
 * <code>Shirako</code> container. A Shirako container measures time in units
 * of cycles. A cycle can have a variable length, which is specified at boot
 * time. Container clocks can optionally be configured with an offset to be
 * applied when calculating the current cycle. For more details about cycles see
 * {@link ActorClock}.
 * <p>
 * Time within the container can advance automatically, based on the internal
 * computer clock, or manually, based on calls to the container clock's
 * <code>tick</code> method. A clock implementation must support at least one
 * mode of execution (manual or automatic), but it need not support both.
 * <p>
 * A Shirako clock implementation maintains a collection of subscribers, which
 * will be notified about the passage of time. Subscriptions are dynamic and can
 * be changed at run time.
 * <p>
 * Abstractly, each subscriber will receive a notification about the advancement
 * of the container clock. Some implementations may guarantee that if an object
 * has received a notification for cycle <code>x</code>, the next
 * notification will be for cycle
 * <code>x+1</code>. However, in general, no such guarantees are provided. As a matter of fact, code
 * executing in real time will often "skip" cycles. Therefore, subscribed object, in general, must be
 * able to handle correctly cases in which one or more clock cycle notifications are omitted.
 */
public interface ITicker extends Initializable
{
    /**
     * Advances the clock with one cycle. This operation is only
     * applicable for manual clocks. This is a blocking operation.
     */
    public void tick();

    /**
     * Starts the clock.
     */
    public void start();

    /**
     * Stops/pauses the clock.
     *
     * @throws Exception in case of error
     */
    public void stop() throws Exception;

    /**
     * Adds an object to the list of objects subscribed to receive tick
     * events.
     *
     * @param tickable object to add
     */
    public void addTickable(ITick tickable);

    /**
     * Removes an object from the list of object subscribed to receive
     * tick events.
     *
     * @param tickable object to remove
     */
    public void removeTickable(ITick tickable);

    /**
     * Stops the clock and unregisters all registered items.
     *
     * @throws Exception in case of error
     */
    public void clear() throws Exception;

    /**
     * Returns the current clock cycle.
     *
     * @return current clock cycle
     */
    public long getCurrentCycle();

    /**
     * Sets the current cycle. The first cycle to be generated by the
     * clock will be cycle+1. This method can called only if
     * <code>initialize</code> has not yet been called.
     *
     * @param cycle current cycle
     */
    public void setCurrentCycle(long cycle);

    /**
     * Sets the clock offset (relative to current time). Clock offset
     * is measured in milliseconds. Clock offset is used to calculate the
     * current clock cycle by subtracting it from current time and dividing by
     * the length of a cycle. This method can called only if
     * <code>initialize</code> has not yet been called.
     *
     * @param value clock offset in milliseconds
     */
    public void setBeginningOfTime(long value);

    /**
     * Returns the clock offset. Clock offset is measured in
     * milliseconds.
     *
     * @return clock offset in milliseconds
     */
    public long getBeginningOfTime();

    /**
     * Returns the cycle length. Cycle length is measured in
     * milliseconds.
     *
     * @return cycle length in milliseconds
     */
    public long getCycleMillis();

    /**
     * Sets the cycle length. Cycle length is measured in milliseconds.
     * This method can called only if <code>initialize</code> has not yet been
     * called.
     *
     * @param cycleMillis cycle length in milliseconds
     */
    public void setCycleMillis(long cycleMillis);

    /**
     * Checks if the clock implementation is manual, i.e., time
     * advances manually as a result of calls to <code>tick</code>.
     *
     * @return true if the clock is manual, false otherwise.
     */
    public boolean isManual();

    /**
     * Sets the manual clock flag. This method may throw a
     * <code>RuntimeException</code> if the clock does not support the
     * particular execution mode. This method can called only if
     * <code>initialize</code> has not yet been called.
     *
     * @param value value for the manual flag
     */
    public void setManual(boolean value);

}
